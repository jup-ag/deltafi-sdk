import { clusterApiUrl, Connection, PublicKey, sendAndConfirmTransaction } from "@solana/web3.js";
import { exit } from "process";
import {
  createSwapTransaction,
  getDeltafiUser,
  createWithdrawTransaction,
  createDepositTransaction,
} from "../anchor/transaction_utils";
import {
  exponentiate,
  getDeploymentConfig,
  getOrCreateAssociatedAccountInfo,
  getPoolConfig,
  getTokenConfig,
  readKeypair,
} from "./utils";
import { Command } from "commander";
import * as https from "https";
import { getSwapOutResult } from "../calculations/swapOutAmount";
import { calculateMinOutAmountDeposit, calculateWithdrawalFromShares } from "../calculations/calculation";
import { bnToAnchorBn, anchorBnToBn } from "../calculations/tokenUtils";
import { getDeltafiDexV2, makeProvider } from "../anchor/anchor_utils";
import { BN } from "@project-serum/anchor";
import { getSymbolToPythPriceData } from "../anchor/pyth_utils";
import BigNumber from "bignumber.js";

const estimatedPrice = {
  SOL: 40,
  USDT: 1,
  USDC: 1,
};

// the example transaction logic
// this function established 2 transaction, first sell USDC for USDT and second sell USDT for USDC
// because we have to wallet keypair in code base, we just sign the transaction generated by the API
// directly with the wallet keypair
// in actually application, we should use wallet sdk for the signature
const doSwap = async (keypairFilePath: string, network: string, poolName: string) => {
  if (network !== "testnet" && network !== "mainnet-beta") {
    console.error("wrong network!");
    exit(1);
  }

  const deployConfig = getDeploymentConfig(network === "mainnet-beta" ? "mainnet-prod" : "testnet");
  const poolConfig = getPoolConfig(deployConfig, poolName);
  console.info("pool config:", poolConfig);

  const connection = new Connection(clusterApiUrl(deployConfig.network), "confirmed");
  const program = getDeltafiDexV2(
    new PublicKey(deployConfig.programId),
    makeProvider(connection, {}),
  );

  const keyPair = readKeypair(keypairFilePath);
  const swapInfo = await program.account.swapInfo.fetch(new PublicKey(poolConfig.swapInfo));
  const deltafiUser = await getDeltafiUser(program, swapInfo.configKey, keyPair.publicKey);
  const symbolToPythPriceData = await getSymbolToPythPriceData(
    connection,
    deployConfig.tokenInfoList,
  );

  const baseTokenConfig = getTokenConfig(deployConfig, poolConfig.base);
  const quoteTokenConfig = getTokenConfig(deployConfig, poolConfig.quote);

  const baseTokenAccount = (
    await getOrCreateAssociatedAccountInfo(
      connection,
      keyPair,
      new PublicKey(baseTokenConfig.mint),
      keyPair.publicKey,
    )
  ).address;
  const quoteTokenAccount = (
    await getOrCreateAssociatedAccountInfo(
      connection,
      keyPair,
      new PublicKey(quoteTokenConfig.mint),
      keyPair.publicKey,
    )
  ).address;

  const inputAmount = new BigNumber("1").div(estimatedPrice[poolConfig.base]);
  console.info(
    `transaction 1: sell ${inputAmount.toFixed(6)} ${poolConfig.base} for ${poolConfig.quote}`,
  );
  const swapoutResult = await getSwapOutResult(
    symbolToPythPriceData,
    swapInfo,
    baseTokenConfig,
    quoteTokenConfig,
    inputAmount.toFixed(6),
    0.1,
  );
  console.info(swapoutResult);

  try {
    const { transaction, signers } = await createSwapTransaction(
      poolConfig,
      program,
      swapInfo,
      deltafiUser,
      keyPair.publicKey,
      baseTokenAccount,
      quoteTokenAccount,
      new BN(exponentiate(inputAmount, baseTokenConfig.decimals).toFixed(0)),
      new BN(
        exponentiate(
          new BigNumber(swapoutResult.amountOutWithSlippage),
          quoteTokenConfig.decimals,
        ).toFixed(0),
      ),
      { sellBase: {} },
    );

    transaction.recentBlockhash = (await connection.getLatestBlockhash("max")).blockhash;
    transaction.feePayer = keyPair.publicKey;

    // may use wallet sdk for signature in application
    const signature = await sendAndConfirmTransaction(connection, transaction, [
      ...signers,
      keyPair,
    ]);
    console.info(
      `transaction ${poolConfig.base} -> ${poolConfig.quote} succeeded with signature: ` +
        signature,
    );
  } catch (e) {
    console.error(`transaction ${poolConfig.base} -> ${poolConfig.quote} failed with error: ` + e);
    exit(1);
  }

  const inputAmount2 = new BigNumber("1").div(estimatedPrice[poolConfig.quote]);
  console.info(
    `transaction 2: sell ${inputAmount2.toFixed(6)} ${poolConfig.quote} for ${poolConfig.base}`,
  );
  const swapoutResult2 = await getSwapOutResult(
    symbolToPythPriceData,
    swapInfo,
    quoteTokenConfig,
    baseTokenConfig,
    inputAmount2.toFixed(6),
    0.1,
  );
  console.info(swapoutResult2);

  try {
    const { transaction, signers } = await createSwapTransaction(
      poolConfig,
      program,
      swapInfo,
      deltafiUser,
      keyPair.publicKey,
      quoteTokenAccount,
      baseTokenAccount,
      new BN(exponentiate(inputAmount2, quoteTokenConfig.decimals).toFixed(0)),
      new BN(
        exponentiate(
          new BigNumber(swapoutResult2.amountOutWithSlippage),
          baseTokenConfig.decimals,
        ).toFixed(0),
      ),
      { sellQuote: {} },
    );

    transaction.recentBlockhash = (await connection.getLatestBlockhash("max")).blockhash;
    transaction.feePayer = keyPair.publicKey;

    // may use wallet sdk for signature in application
    const signature = await sendAndConfirmTransaction(connection, transaction, [
      ...signers,
      keyPair,
    ]);
    console.info(
      `transaction ${poolConfig.quote} -> ${poolConfig.base} succeeded with signature: ` +
        signature,
    );
  } catch (e) {
    console.error(`transaction ${poolConfig.quote} -> ${poolConfig.base} failed with error: ` + e);
    exit(1);
  }
};

const doDeposit = async (keypairFilePath: string, network: string, poolName: string) => {
  if (network !== "testnet" && network !== "mainnet-beta") {
    console.error("wrong network!");
    exit(1);
  }

  const deployConfig = getDeploymentConfig(network === "mainnet-beta" ? "mainnet-prod" : "testnet");
  const poolConfig = getPoolConfig(deployConfig, poolName);
  console.info("pool config:", poolConfig);

  const baseTokenConfig = getTokenConfig(deployConfig, poolConfig.base);
  const quoteTokenConfig = getTokenConfig(deployConfig, poolConfig.quote);

  const keyPair = readKeypair(keypairFilePath);
  const connection = new Connection(clusterApiUrl(deployConfig.network), "confirmed");

  const program = getDeltafiDexV2(
    new PublicKey(deployConfig.programId),
    makeProvider(connection, {}),
  );

  const baseTokenAccount = (
    await getOrCreateAssociatedAccountInfo(
      connection,
      keyPair,
      new PublicKey(baseTokenConfig.mint),
      keyPair.publicKey,
    )
  ).address;
  const quoteTokenAccount = (
    await getOrCreateAssociatedAccountInfo(
      connection,
      keyPair,
      new PublicKey(quoteTokenConfig.mint),
      keyPair.publicKey,
    )
  ).address;

  const poolPubkey = new PublicKey(poolConfig.swapInfo);
  const swapInfo = await program.account.swapInfo.fetch(poolPubkey);

  const [lpPublicKey] = await PublicKey.findProgramAddress(
    [
      Buffer.from("LiquidityProvider"),
      new PublicKey(poolConfig.swapInfo).toBuffer(),
      keyPair.publicKey.toBuffer(),
    ],
    program.programId,
  );
  const lpUser = await program.account.liquidityProvider.fetchNullable(lpPublicKey);

  const baseAmount = new BigNumber(1).div(estimatedPrice[poolConfig.base]);
  const quoteAmount = new BigNumber(1).div(estimatedPrice[poolConfig.quote]);
  console.info(
    `Depositing ${baseAmount.toString()} ${baseTokenConfig.symbol} and ` +
      `${quoteAmount.toString()} ${quoteTokenConfig.symbol}`,
  );

  const minCoeff = new BigNumber(0.99);
  const { minBaseShare, minQuoteShare } = calculateMinOutAmountDeposit(
    swapInfo,
    baseAmount,
    quoteAmount,
    new BigNumber(swapInfo.poolState.marketPrice.toString()),
    minCoeff,
  );

  try {
    const { transaction, signers } = await createDepositTransaction(
      poolConfig,
      program,
      swapInfo,
      baseTokenAccount,
      quoteTokenAccount,
      keyPair.publicKey,
      lpUser,
      new BN(exponentiate(baseAmount, baseTokenConfig.decimals).toFixed(0)),
      new BN(exponentiate(quoteAmount, quoteTokenConfig.decimals).toFixed(0)),
      bnToAnchorBn(baseTokenConfig, minBaseShare),
      bnToAnchorBn(quoteTokenConfig, minQuoteShare),
    );

    transaction.recentBlockhash = (await connection.getLatestBlockhash("max")).blockhash;
    transaction.feePayer = keyPair.publicKey;

    const signature = await sendAndConfirmTransaction(connection, transaction, [
      ...signers,
      keyPair,
    ]);
    console.info("deposit succeeded with signature: " + signature);
  } catch (e) {
    console.error("deposit failed with error: " + e);
    exit(1);
  }
};

const doWithdraw = async (keypairFilePath: string, network: string, poolName: string) => {
  if (network !== "testnet" && network !== "mainnet-beta") {
    console.error("wrong network!");
    exit(1);
  }

  const deployConfig = getDeploymentConfig(network === "mainnet-beta" ? "mainnet-prod" : "testnet");
  const poolConfig = getPoolConfig(deployConfig, poolName);
  console.info("pool config:", poolConfig);

  const baseTokenConfig = getTokenConfig(deployConfig, poolConfig.base);
  const quoteTokenConfig = getTokenConfig(deployConfig, poolConfig.quote);

  const keyPair = readKeypair(keypairFilePath);
  const connection = new Connection(clusterApiUrl(deployConfig.network), "confirmed");

  const symbolToPythPriceData = await getSymbolToPythPriceData(
    connection,
    deployConfig.tokenInfoList,
  );

  const program = getDeltafiDexV2(
    new PublicKey(deployConfig.programId),
    makeProvider(connection, {}),
  );

  const baseTokenAccount = (
    await getOrCreateAssociatedAccountInfo(
      connection,
      keyPair,
      new PublicKey(baseTokenConfig.mint),
      keyPair.publicKey,
    )
  ).address;
  const quoteTokenAccount = (
    await getOrCreateAssociatedAccountInfo(
      connection,
      keyPair,
      new PublicKey(quoteTokenConfig.mint),
      keyPair.publicKey,
    )
  ).address;

  const poolPubkey = new PublicKey(poolConfig.swapInfo);
  const swapInfo = await program.account.swapInfo.fetch(poolPubkey);

  const [lpPublicKey] = await PublicKey.findProgramAddress(
    [
      Buffer.from("LiquidityProvider"),
      new PublicKey(poolConfig.swapInfo).toBuffer(),
      keyPair.publicKey.toBuffer(),
    ],
    program.programId,
  );
  const lpUser = await program.account.liquidityProvider.fetchNullable(lpPublicKey);

  // Withdraw all the available shares
  const baseShare = lpUser.baseShare.toNumber() - lpUser.stakedBaseShare.toNumber();
  const quoteShare = lpUser.quoteShare.toNumber() - lpUser.stakedBaseShare.toNumber();
  console.info(
    `Withdrawing ${baseShare} ${baseTokenConfig.symbol} and ` +
      `${quoteShare} ${quoteTokenConfig.symbol}`,
  );

  const minCoeff = new BigNumber(0.99);
  const { baseWithdrawalAmount, quoteWithdrawalAmount } = calculateWithdrawalFromShares(
    baseShare,
    quoteShare,
    baseTokenConfig,
    quoteTokenConfig,
    symbolToPythPriceData[baseTokenConfig.symbol].price,
    symbolToPythPriceData[quoteTokenConfig.symbol].price,
    swapInfo?.poolState,
  );

  const minBaseAmount = minCoeff.multipliedBy(new BigNumber(baseWithdrawalAmount));
  const minQuoteAmount = minCoeff.multipliedBy(new BigNumber(quoteWithdrawalAmount));

  try {
    const { transaction, signers } = await createWithdrawTransaction(
      poolConfig,
      program,
      swapInfo,
      baseTokenAccount,
      quoteTokenAccount,
      keyPair.publicKey,
      new BN(baseShare),
      new BN(quoteShare),
      bnToAnchorBn(baseTokenConfig, minBaseAmount),
      bnToAnchorBn(quoteTokenConfig, minQuoteAmount),
    );

    transaction.recentBlockhash = (await connection.getLatestBlockhash("max")).blockhash;
    transaction.feePayer = keyPair.publicKey;

    const signature = await sendAndConfirmTransaction(connection, transaction, [
      ...signers,
      keyPair,
    ]);
    console.info("withdraw succeeded with signature: " + signature);
  } catch (e) {
    console.error("withdraw failed with error: " + e);
    exit(1);
  }
};

const getConfig = async () => {
  const options = {
    hostname: "app.deltafi.trade",
    port: 443,
    path: "/api/config",
    method: "GET",
  };

  const req = https.request(options, (res) => {
    res.on("data", (data) => {
      // pretty print the config json
      console.log(JSON.stringify(JSON.parse(Buffer.from(data).toString()), null, 2));
    });
  });

  req.on("error", (error) => {
    console.error(error);
  });

  req.end();
};

const main = () => {
  const program = new Command();
  program
    .command("swap")
    .option("-k --keypair <wallet keypair for example transactions>")
    .option("-n --network <mainnet-beta or testnet>")
    .option("--pool <pool name>")
    .action(async (option) => {
      doSwap(option.keypair, option.network, option.pool || "USDC-USDT");
    });

  program
    .command("deposit")
    .option("-k --keypair <wallet keypair for example transactions>")
    .option("-n --network <mainnet-beta or testnet>")
    .option("--pool <pool name>")
    .action(async (option) => {
      doDeposit(option.keypair, option.network, option.pool || "USDC-USDT");
    });

  program
    .command("withdraw")
    .option("-k --keypair <wallet keypair for example transactions>")
    .option("-n --network <mainnet-beta or testnet>")
    .option("--pool <pool name>")
    .action(async (option) => {
      doWithdraw(option.keypair, option.network, option.pool || "USDC-USDT");
    });

  program.command("get-config").action(getConfig);

  program.parse(process.argv);
};

main();
